import { RecurringTransaction, Transaction, RecurrenceFrequency } from '@/types';
import { addDays, addWeeks, addMonths, addYears, isBefore, isEqual, parseISO } from 'date-fns';

/**
 * Calculate the next occurrence date based on frequency
 */
export function calculateNextOccurrence(
    currentDate: Date,
    frequency: RecurrenceFrequency
): Date {
    switch (frequency) {
        case 'daily':
            return addDays(currentDate, 1);
        case 'weekly':
            return addWeeks(currentDate, 1);
        case 'monthly':
            return addMonths(currentDate, 1);
        case 'yearly':
            return addYears(currentDate, 1);
        default:
            return addMonths(currentDate, 1);
    }
}

/**
 * Check if a recurring transaction is due for generation
 */
export function isRecurringDue(recurring: RecurringTransaction, currentDate: Date): boolean {
    const nextDate = parseISO(recurring.nextDate);
    return isBefore(nextDate, currentDate) || isEqual(nextDate, currentDate);
}

/**
 * Generate a transaction from a recurring template
 */
export function generateTransactionFromRecurring(
    recurring: RecurringTransaction,
    date?: Date
): Transaction {
    const transactionDate = date || parseISO(recurring.nextDate);

    return {
        id: '', // Will be generated by the store
        date: transactionDate.toISOString().split('T')[0],
        type: recurring.type,
        category: recurring.category,
        description: recurring.description,
        amount: recurring.amount,
        currency: recurring.currency,
        tags: recurring.tags,
        recurringId: recurring.id,
    };
}

/**
 * Check if recurring transaction should end
 */
export function shouldEndRecurring(
    recurring: RecurringTransaction,
    currentDate: Date
): boolean {
    // Check if end date has been reached
    if (recurring.endDate) {
        const endDate = parseISO(recurring.endDate);
        return isBefore(endDate, currentDate) || isEqual(endDate, currentDate);
    }

    return false;
}

/**
 * Process all recurring transactions and generate due ones
 * Returns new transactions to add and updated recurring transactions
 */
export function processRecurringTransactions(
    recurringTransactions: RecurringTransaction[],
    currentDate: Date
): {
    newTransactions: Omit<Transaction, 'id'>[];
    updatedRecurring: RecurringTransaction[];
} {
    const newTransactions: Omit<Transaction, 'id'>[] = [];
    const updatedRecurring: RecurringTransaction[] = [];

    recurringTransactions.forEach((recurring) => {
        // Skip inactive recurring transactions
        if (!recurring.isActive) {
            updatedRecurring.push(recurring);
            return;
        }

        // Check if it should end
        if (shouldEndRecurring(recurring, currentDate)) {
            updatedRecurring.push({
                ...recurring,
                isActive: false,
            });
            return;
        }

        // Check if it's due
        if (isRecurringDue(recurring, currentDate)) {
            // Generate transaction
            const newTransaction = generateTransactionFromRecurring(recurring);
            newTransactions.push(newTransaction);

            // Calculate next occurrence
            const nextOccurrence = calculateNextOccurrence(
                parseISO(recurring.nextDate),
                recurring.frequency
            );

            updatedRecurring.push({
                ...recurring,
                nextDate: nextOccurrence.toISOString().split('T')[0],
            });
        } else {
            // No changes needed
            updatedRecurring.push(recurring);
        }
    });

    return { newTransactions, updatedRecurring };
}

/**
 * Get a user-friendly description of the frequency
 */
export function getFrequencyLabel(frequency: RecurrenceFrequency): string {
    const labels: Record<RecurrenceFrequency, string> = {
        daily: 'Daily',
        weekly: 'Weekly',
        monthly: 'Monthly',
        yearly: 'Yearly',
    };
    return labels[frequency];
}

/**
 * Calculate how many occurrences remain until end date
 */
export function calculateRemainingOccurrences(
    startDate: Date,
    endDate: Date,
    frequency: RecurrenceFrequency
): number {
    let count = 0;
    let currentDate = new Date(startDate);

    while (isBefore(currentDate, endDate) || isEqual(currentDate, endDate)) {
        count++;
        currentDate = calculateNextOccurrence(currentDate, frequency);

        // Safety limit to prevent infinite loops
        if (count > 10000) break;
    }

    return count;
}
